/*
 * Copyright (C) 2012 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License. You may obtain a copy of
 * the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */

package com.android.inputmethod.research;

import com.android.inputmethod.latin.CollectionUtils;

import java.util.List;

/**
 * A group of log statements related to each other.
 *
 * A LogUnit is collection of LogStatements, each of which is generated by at a particular point
 * in the code.  (There is no LogStatement class; the data is stored across the instance variables
 * here.)  A single LogUnit's statements can correspond to all the calls made while in the same
 * composing region, or all the calls between committing the last composing region, and the first
 * character of the next composing region.
 *
 * Individual statements in a log may be marked as potentially private.  If so, then they are only
 * published to a ResearchLog if the ResearchLogger determines that publishing the entire LogUnit
 * will not violate the user's privacy.  Checks for this may include whether other LogUnits have
 * been published recently, or whether the LogUnit contains numbers, etc.
 */
/* package */ class LogUnit {
    private final List<String[]> mKeysList;
    private final List<Object[]> mValuesList;
    // Assume that mTimeList is sorted in increasing order.  Do not insert null values into
    // mTimeList.
    private final List<Long> mTimeList;
    private final List<Boolean> mIsPotentiallyPrivate;
    private String mWord;
    private boolean mContainsDigit;

    public LogUnit() {
        mKeysList = CollectionUtils.newArrayList();
        mValuesList = CollectionUtils.newArrayList();
        mTimeList = CollectionUtils.newArrayList();
        mIsPotentiallyPrivate = CollectionUtils.newArrayList();
    }

    private LogUnit(final List<String[]> keysList, final List<Object[]> valuesList,
            final List<Long> timeList, final List<Boolean> isPotentiallyPrivate) {
        mKeysList = keysList;
        mValuesList = valuesList;
        mTimeList = timeList;
        mIsPotentiallyPrivate = isPotentiallyPrivate;
    }

    /**
     * Adds a new log statement.  The time parameter in successive calls to this method must be
     * monotonically increasing, or splitByTime() will not work.
     */
    public void addLogStatement(final String[] keys, final Object[] values,
            final long time, final boolean isPotentiallyPrivate) {
        mKeysList.add(keys);
        mValuesList.add(values);
        mTimeList.add(time);
        mIsPotentiallyPrivate.add(isPotentiallyPrivate);
    }

    public void publishTo(final ResearchLog researchLog, final boolean isIncludingPrivateData) {
        final int size = mKeysList.size();
        for (int i = 0; i < size; i++) {
            if (!mIsPotentiallyPrivate.get(i) || isIncludingPrivateData) {
                researchLog.outputEvent(mKeysList.get(i), mValuesList.get(i), mTimeList.get(i));
            }
        }
    }

    public void setWord(String word) {
        mWord = word;
    }

    public String getWord() {
        return mWord;
    }

    public boolean hasWord() {
        return mWord != null;
    }

    public void setContainsDigit() {
        mContainsDigit = true;
    }

    public boolean hasDigit() {
        return mContainsDigit;
    }

    public boolean isEmpty() {
        return mKeysList.isEmpty();
    }

    /**
     * Split this logUnit, with all events before maxTime staying in the current logUnit, and all
     * events after maxTime going into a new LogUnit that is returned.
     */
    public LogUnit splitByTime(final long maxTime) {
        // Assume that mTimeList is in sorted order.
        final int length = mTimeList.size();
        for (int index = 0; index < length; index++) {
            if (mTimeList.get(index) >= maxTime) {
                final LogUnit newLogUnit = new LogUnit(
                        mKeysList.subList(index, length),
                        mValuesList.subList(index, length),
                        mTimeList.subList(index, length),
                        mIsPotentiallyPrivate.subList(index, length));
                newLogUnit.mWord = null;
                newLogUnit.mContainsDigit = mContainsDigit;
                return newLogUnit;
            }
        }
        return new LogUnit();
    }
}
